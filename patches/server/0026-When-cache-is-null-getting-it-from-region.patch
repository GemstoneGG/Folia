From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: killerprojecte <admin@fastmcmirror.org>
Date: Mon, 19 Jun 2023 21:30:33 +0800
Subject: [PATCH] When cache is null getting it from region


diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 98b69acf7691c79bfae86d7415b30916c9370261..79c79c57a17dc0cad735cd1b4a776510930e163f 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -5,6 +5,7 @@ import com.destroystokyo.paper.exception.ServerInternalException;
 import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import dev.rgbmc.folia.CachedWorldData;
+import dev.rgbmc.folia.FakePlugin;
 import io.papermc.paper.util.MCUtil;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
@@ -76,6 +77,7 @@ import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
+import java.util.concurrent.CompletableFuture;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
@@ -252,7 +254,15 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public io.papermc.paper.threadedregions.RegionizedWorldData getCurrentWorldData() {
         final io.papermc.paper.threadedregions.RegionizedWorldData ret = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData();
         if (ret == null) {
-            return CachedWorldData.get(world.getName()); // DirtyFolia - cache world data
+            io.papermc.paper.threadedregions.RegionizedWorldData cached = CachedWorldData.get(world.getName());
+            if (cached != null) {
+                return cached; // DirtyFolia - cache world data
+            }
+            CompletableFuture<io.papermc.paper.threadedregions.RegionizedWorldData> future = new CompletableFuture<>();
+            Bukkit.getRegionScheduler().run(new FakePlugin(), getWorld(), 0, 0, task -> {
+                future.complete(io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData());
+            });
+            return future.join();
         }
         CachedWorldData.update(world.getName(), ret);
         Level world = ret.world;
